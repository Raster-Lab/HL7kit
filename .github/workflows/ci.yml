name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop, copilot/** ]
  pull_request:
    branches: [ main, develop ]

jobs:
  build-and-test:
    name: Build and Test
    runs-on: macos-latest
    outputs:
      coverage: ${{ steps.coverage.outputs.coverage }}
      test_passed: ${{ steps.test-results.outputs.passed }}
      test_failed: ${{ steps.test-results.outputs.failed }}
      test_skipped: ${{ steps.test-results.outputs.skipped }}
      test_total: ${{ steps.test-results.outputs.total }}
      build_time: ${{ steps.build-timing.outputs.duration }}
      test_time: ${{ steps.test-timing.outputs.duration }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup Xcode
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: latest-stable
    
    - name: Capture environment info
      id: env-info
      run: |
        SWIFT_VERSION=$(swift --version 2>&1 | head -1)
        XCODE_VERSION=$(xcodebuild -version 2>/dev/null | head -1 || echo "N/A")
        OS_VERSION=$(sw_vers -productVersion 2>/dev/null || echo "N/A")
        echo "swift_version=${SWIFT_VERSION}" >> $GITHUB_OUTPUT
        echo "xcode_version=${XCODE_VERSION}" >> $GITHUB_OUTPUT
        echo "os_version=${OS_VERSION}" >> $GITHUB_OUTPUT
    
    - name: Build package
      id: build-timing
      run: |
        BUILD_START=$(date +%s)
        swift build -v 2>&1 | tee build-output.log
        BUILD_EXIT=$?
        BUILD_END=$(date +%s)
        DURATION=$((BUILD_END - BUILD_START))
        echo "duration=${DURATION}" >> $GITHUB_OUTPUT
        echo "exit_code=${BUILD_EXIT}" >> $GITHUB_OUTPUT
        exit $BUILD_EXIT

    - name: Build tests
      run: swift build --build-tests
    
    - name: Run tests with coverage
      id: test-timing
      run: |
        TEST_START=$(date +%s)
        swift test --enable-code-coverage 2>&1 | tee test-output.log
        TEST_EXIT=$?
        TEST_END=$(date +%s)
        DURATION=$((TEST_END - TEST_START))
        echo "duration=${DURATION}" >> $GITHUB_OUTPUT
        # Check for actual test failures vs runtime signal crashes
        if [ $TEST_EXIT -ne 0 ]; then
          if grep -q "with [1-9][0-9]* failure" test-output.log; then
            echo "Tests failed with actual test failures"
            exit 1
          elif grep -q "error: fatalError" test-output.log; then
            echo "Build failed with compilation errors"
            exit 1
          else
            echo "::warning::Test runner exited with code $TEST_EXIT but no test failures detected (likely a signal crash during teardown)"
          fi
        fi

    - name: Parse test results
      if: always()
      id: test-results
      run: |
        if [ -f test-output.log ]; then
          # Parse per-module test results from swift test output
          # Swift test output format: "Test Suite 'SomeTests' passed at ..."
          # and final: "Executed N tests, with M failures ... in T seconds"
          
          PASSED=0
          FAILED=0
          SKIPPED=0
          
          # Count individual test case results
          PASSED=$(grep -c "Test Case.*passed" test-output.log 2>/dev/null || true)
          FAILED=$(grep -c "Test Case.*failed" test-output.log 2>/dev/null || true)
          SKIPPED=$(grep -c "Test Case.*skipped" test-output.log 2>/dev/null || true)
          PASSED=${PASSED:-0}
          FAILED=${FAILED:-0}
          SKIPPED=${SKIPPED:-0}
          TOTAL=$((PASSED + FAILED + SKIPPED))
          
          echo "passed=${PASSED}" >> $GITHUB_OUTPUT
          echo "failed=${FAILED}" >> $GITHUB_OUTPUT
          echo "skipped=${SKIPPED}" >> $GITHUB_OUTPUT
          echo "total=${TOTAL}" >> $GITHUB_OUTPUT
          
          # Parse per-module test results
          # Modules: HL7CoreTests, HL7v2KitTests, HL7v3KitTests, FHIRkitTests, HL7CLITests
          {
            echo "MODULE_RESULTS<<EOF"
            for MODULE in HL7CoreTests HL7v2KitTests HL7v3KitTests FHIRkitTests HL7CLITests; do
              M_PASSED=$(grep "Test Case.*${MODULE}" test-output.log 2>/dev/null | grep -c "passed" || true)
              M_FAILED=$(grep "Test Case.*${MODULE}" test-output.log 2>/dev/null | grep -c "failed" || true)
              M_SKIPPED=$(grep "Test Case.*${MODULE}" test-output.log 2>/dev/null | grep -c "skipped" || true)
              M_PASSED=${M_PASSED:-0}
              M_FAILED=${M_FAILED:-0}
              M_SKIPPED=${M_SKIPPED:-0}
              M_TOTAL=$((M_PASSED + M_FAILED + M_SKIPPED))
              if [ $M_TOTAL -gt 0 ]; then
                if [ $M_FAILED -gt 0 ]; then
                  M_STATUS="‚ùå"
                else
                  M_STATUS="‚úÖ"
                fi
              else
                M_STATUS="‚ö™"
              fi
              echo "${MODULE}|${M_PASSED}|${M_FAILED}|${M_SKIPPED}|${M_TOTAL}|${M_STATUS}"
            done
            echo "EOF"
          } >> $GITHUB_OUTPUT
        else
          echo "passed=0" >> $GITHUB_OUTPUT
          echo "failed=0" >> $GITHUB_OUTPUT
          echo "skipped=0" >> $GITHUB_OUTPUT
          echo "total=0" >> $GITHUB_OUTPUT
        fi
    
    - name: Generate coverage report
      if: always()
      run: |
        xcrun llvm-cov export -format="lcov" \
          .build/debug/HL7kitPackageTests.xctest/Contents/MacOS/HL7kitPackageTests \
          -instr-profile .build/debug/codecov/default.profdata > coverage.lcov || true
    
    - name: Calculate coverage percentage
      if: always()
      id: coverage
      run: |
        if [ -f coverage.lcov ]; then
          # Overall coverage
          COVERAGE=$(awk '
            /^LF:/ { split($0, a, ":"); total_lines += a[2] }
            /^LH:/ { split($0, a, ":"); covered_lines += a[2] }
            END { 
              if (total_lines > 0) {
                printf "%.1f", (covered_lines / total_lines) * 100
              } else {
                print "0.0"
              }
            }' coverage.lcov)
          echo "coverage=${COVERAGE}" >> $GITHUB_OUTPUT
          
          # Per-module coverage breakdown
          {
            echo "MODULE_COVERAGE<<EOF"
            for MODULE in HL7Core HL7v2Kit HL7v3Kit FHIRkit HL7CLI; do
              MOD_COVERAGE=$(awk -v mod="Sources/${MODULE}/" '
                BEGIN { in_mod=0; total=0; covered=0 }
                /^SF:/ { in_mod = (index($0, mod) > 0) }
                /^LF:/ && in_mod { split($0, a, ":"); total += a[2] }
                /^LH:/ && in_mod { split($0, a, ":"); covered += a[2] }
                END {
                  if (total > 0) {
                    printf "%.1f", (covered / total) * 100
                  } else {
                    print "N/A"
                  }
                }' coverage.lcov)
              echo "${MODULE}|${MOD_COVERAGE}" 
            done
            echo "EOF"
          } >> $GITHUB_OUTPUT
        else
          echo "coverage=0.0" >> $GITHUB_OUTPUT
        fi
    
    - name: Generate CI report
      if: always()
      run: |
        REPORT_FILE=$GITHUB_STEP_SUMMARY
        COVERAGE="${{ steps.coverage.outputs.coverage }}"
        PASSED="${{ steps.test-results.outputs.passed }}"
        FAILED="${{ steps.test-results.outputs.failed }}"
        SKIPPED="${{ steps.test-results.outputs.skipped }}"
        TOTAL="${{ steps.test-results.outputs.total }}"
        BUILD_TIME="${{ steps.build-timing.outputs.duration }}"
        TEST_TIME="${{ steps.test-timing.outputs.duration }}"
        THRESHOLD=90
        
        # --- Report Header ---
        cat >> "$REPORT_FILE" << 'HEADER'
        # üìä CI/CD Pipeline Report
        
        HEADER
        
        # --- Environment ---
        cat >> "$REPORT_FILE" << ENVEOF
        <details>
        <summary>üñ•Ô∏è Environment</summary>
        
        | Property | Value |
        |----------|-------|
        | **Swift** | ${{ steps.env-info.outputs.swift_version }} |
        | **Xcode** | ${{ steps.env-info.outputs.xcode_version }} |
        | **macOS** | ${{ steps.env-info.outputs.os_version }} |
        | **Runner** | \`${{ runner.os }}\` |
        | **Ref** | \`${{ github.ref_name }}\` |
        | **SHA** | \`${{ github.sha }}\` |
        
        </details>
        
        ENVEOF
        
        # --- Build Summary ---
        BUILD_EXIT="${{ steps.build-timing.outputs.exit_code }}"
        if [ "$BUILD_EXIT" = "0" ] || [ -z "$BUILD_EXIT" ]; then
          BUILD_STATUS="‚úÖ Passed"
        else
          BUILD_STATUS="‚ùå Failed"
        fi
        
        cat >> "$REPORT_FILE" << BUILDEOF
        ## üî® Build
        
        | Metric | Value |
        |--------|-------|
        | **Status** | ${BUILD_STATUS} |
        | **Duration** | ${BUILD_TIME}s |
        
        BUILDEOF
        
        # --- Test Results ---
        if [ "$FAILED" -gt 0 ] 2>/dev/null; then
          TEST_STATUS="‚ùå ${FAILED} failure(s)"
        elif [ "$TOTAL" -gt 0 ] 2>/dev/null; then
          TEST_STATUS="‚úÖ All passed"
        else
          TEST_STATUS="‚ö™ No results"
        fi
        
        cat >> "$REPORT_FILE" << TESTEOF
        ## üß™ Tests
        
        | Metric | Value |
        |--------|-------|
        | **Status** | ${TEST_STATUS} |
        | **Duration** | ${TEST_TIME}s |
        | **Total** | ${TOTAL} |
        | ‚úÖ **Passed** | ${PASSED} |
        | ‚ùå **Failed** | ${FAILED} |
        | ‚è≠Ô∏è **Skipped** | ${SKIPPED} |
        
        TESTEOF
        
        # Per-module test results table
        cat >> "$REPORT_FILE" << 'MODTESTHDR'
        <details>
        <summary>üìã Per-Module Test Results</summary>
        
        | Module | Passed | Failed | Skipped | Total | Status |
        |--------|-------:|-------:|--------:|------:|--------|
        MODTESTHDR
        
        echo '${{ steps.test-results.outputs.MODULE_RESULTS }}' | while IFS='|' read -r MOD MP MF MS MT MSTAT; do
          [ -z "$MOD" ] && continue
          echo "| ${MOD} | ${MP} | ${MF} | ${MS} | ${MT} | ${MSTAT} |" >> "$REPORT_FILE"
        done
        
        cat >> "$REPORT_FILE" << 'MODTESTFTR'
        
        </details>
        
        MODTESTFTR
        
        # --- Coverage ---
        COVERAGE_INT=$(echo "${COVERAGE}" | cut -d. -f1)
        if [ "${COVERAGE_INT}" -ge "${THRESHOLD}" ] 2>/dev/null; then
          COV_STATUS="‚úÖ"
          COV_ICON="üü¢"
        else
          COV_STATUS="‚ö†Ô∏è"
          COV_ICON="üü°"
        fi
        
        # Generate visual progress bar
        if [ "${COVERAGE_INT}" -gt 0 ] 2>/dev/null; then
          FILLED=$((COVERAGE_INT / 5))
          EMPTY=$((20 - FILLED))
          BAR=""
          if [ "$FILLED" -gt 0 ]; then
            BAR=$(printf '‚ñà%.0s' $(seq 1 $FILLED))
          fi
          if [ "$EMPTY" -gt 0 ]; then
            BAR="${BAR}$(printf '‚ñë%.0s' $(seq 1 $EMPTY))"
          fi
        else
          BAR="‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë"
        fi
        
        cat >> "$REPORT_FILE" << COVEOF
        ## üìà Code Coverage
        
        ${COV_ICON} **${COVERAGE}%** ${BAR} (threshold: ${THRESHOLD}%)
        
        ${COV_STATUS} Coverage $([ "${COVERAGE_INT}" -ge "${THRESHOLD}" ] 2>/dev/null && echo "meets" || echo "is below") the ${THRESHOLD}% threshold
        
        COVEOF
        
        # Per-module coverage table
        if [ -n "${{ steps.coverage.outputs.MODULE_COVERAGE }}" ]; then
          cat >> "$REPORT_FILE" << 'MODCOVHDR'
        <details>
        <summary>üìä Per-Module Coverage</summary>
        
        | Module | Coverage | Status |
        |--------|----------|--------|
        MODCOVHDR
          
          echo '${{ steps.coverage.outputs.MODULE_COVERAGE }}' | while IFS='|' read -r MOD MCOV; do
            [ -z "$MOD" ] && continue
            MCOV_INT=$(echo "${MCOV}" | cut -d. -f1)
            if [ "${MCOV}" = "N/A" ]; then
              MCOV_STATUS="‚ö™ N/A"
            elif [ "${MCOV_INT}" -ge "${THRESHOLD}" ] 2>/dev/null; then
              MCOV_STATUS="‚úÖ"
            else
              MCOV_STATUS="‚ö†Ô∏è"
            fi
            if [ "${MCOV}" = "N/A" ]; then
              echo "| ${MOD} | N/A | ${MCOV_STATUS} |" >> "$REPORT_FILE"
            else
              echo "| ${MOD} | ${MCOV}% | ${MCOV_STATUS} |" >> "$REPORT_FILE"
            fi
          done
          
          cat >> "$REPORT_FILE" << 'MODCOVFTR'
        
        </details>
        
        MODCOVFTR
        fi
        
        # --- Footer ---
        cat >> "$REPORT_FILE" << FOOTEOF
        ---
        <sub>Generated by CI/CD Pipeline ‚Ä¢ $(date -u '+%Y-%m-%d %H:%M:%S UTC') ‚Ä¢ Run [#${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})</sub>
        FOOTEOF
    
    - name: Upload coverage to Codecov
      if: always()
      uses: codecov/codecov-action@v4
      with:
        files: ./coverage.lcov
        fail_ci_if_error: false
        verbose: true
      continue-on-error: true
    
    - name: Archive test results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: test-results
        path: |
          test-output.log
          coverage.lcov
        retention-days: 30

  lint:
    name: SwiftLint
    runs-on: macos-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Install SwiftLint
      run: brew install swiftlint
    
    - name: Run SwiftLint
      id: swiftlint
      run: |
        swiftlint lint --reporter github-actions-logging 2>&1 | tee swiftlint-output.log || true
        # Also generate JSON report for summary
        swiftlint lint --reporter json > swiftlint-report.json 2>/dev/null || true
      continue-on-error: true

    - name: Generate lint report
      if: always()
      run: |
        REPORT_FILE=$GITHUB_STEP_SUMMARY
        
        cat >> "$REPORT_FILE" << 'HEADER'
        # üîç SwiftLint Report
        
        HEADER
        
        if [ -f swiftlint-report.json ]; then
          ERRORS=$(python3 -c "
        import json, sys
        try:
            with open('swiftlint-report.json') as f:
                data = json.load(f)
            errors = sum(1 for v in data if v.get('severity','') == 'Error')
            warnings = sum(1 for v in data if v.get('severity','') == 'Warning')
            print(f'{errors}|{warnings}|{len(data)}')
        except (FileNotFoundError, json.JSONDecodeError, KeyError, TypeError):
            print('0|0|0')
        " 2>/dev/null || echo "0|0|0")
          
          LINT_ERRORS=$(echo "$ERRORS" | cut -d'|' -f1)
          LINT_WARNINGS=$(echo "$ERRORS" | cut -d'|' -f2)
          LINT_TOTAL=$(echo "$ERRORS" | cut -d'|' -f3)
          
          if [ "$LINT_ERRORS" -gt 0 ] 2>/dev/null; then
            LINT_STATUS="‚ùå ${LINT_ERRORS} error(s)"
          elif [ "$LINT_WARNINGS" -gt 0 ] 2>/dev/null; then
            LINT_STATUS="‚ö†Ô∏è ${LINT_WARNINGS} warning(s)"
          else
            LINT_STATUS="‚úÖ No issues"
          fi
          
          cat >> "$REPORT_FILE" << LINTEOF
        | Metric | Value |
        |--------|-------|
        | **Status** | ${LINT_STATUS} |
        | **Total Issues** | ${LINT_TOTAL} |
        | üî¥ **Errors** | ${LINT_ERRORS} |
        | üü° **Warnings** | ${LINT_WARNINGS} |
        
        LINTEOF
          
          # Show top violations if any
          if [ "$LINT_TOTAL" -gt 0 ] 2>/dev/null; then
            cat >> "$REPORT_FILE" << 'DETHDR'
        <details>
        <summary>üìã Violation Details</summary>
        
        | File | Line | Severity | Rule |
        |------|-----:|----------|------|
        DETHDR
            
            python3 -c "
        import json
        try:
            with open('swiftlint-report.json') as f:
                data = json.load(f)
            for v in data[:50]:
                sev = 'üî¥' if v.get('severity','') == 'Error' else 'üü°'
                fname = v.get('file','').split('/')[-1]
                line = v.get('line', 0)
                rule = v.get('rule_id', 'unknown')
                print(f'| {fname} | {line} | {sev} | \`{rule}\` |')
            if len(data) > 50:
                print(f'| ... | ... | ... | *({len(data)-50} more)* |')
        except (FileNotFoundError, json.JSONDecodeError, KeyError, TypeError):
            print('| N/A | N/A | N/A | *Error reading report* |')
        " >> "$REPORT_FILE" 2>/dev/null || true
            
            cat >> "$REPORT_FILE" << 'DETFTR'
        
        </details>
        
        DETFTR
          fi
        else
          echo "‚ö™ No lint report available" >> "$REPORT_FILE"
        fi
        
        cat >> "$REPORT_FILE" << FOOTEOF
        ---
        <sub>Generated by CI/CD Pipeline ‚Ä¢ $(date -u '+%Y-%m-%d %H:%M:%S UTC')</sub>
        FOOTEOF

    - name: Archive lint results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: lint-results
        path: |
          swiftlint-report.json
        retention-days: 30
      continue-on-error: true

  documentation:
    name: Generate Documentation
    runs-on: macos-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup Xcode
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: latest-stable
    
    - name: Generate documentation
      id: docgen
      run: |
        DOC_RESULTS=""
        for TARGET in HL7Core HL7v2Kit HL7v3Kit FHIRkit; do
          if swift package --allow-writing-to-directory ./docs \
            generate-documentation --target "$TARGET" --output-path "./docs/${TARGET}" 2>&1; then
            DOC_RESULTS="${DOC_RESULTS}${TARGET}|‚úÖ Generated\n"
          else
            DOC_RESULTS="${DOC_RESULTS}${TARGET}|‚ö†Ô∏è Failed\n"
          fi
        done
        {
          echo "DOC_RESULTS<<EOF"
          echo -e "$DOC_RESULTS"
          echo "EOF"
        } >> $GITHUB_OUTPUT
      continue-on-error: true

    - name: Generate documentation report
      if: always()
      run: |
        REPORT_FILE=$GITHUB_STEP_SUMMARY

        cat >> "$REPORT_FILE" << 'HEADER'
        # üìö Documentation Report
        
        | Module | Status |
        |--------|--------|
        HEADER

        echo '${{ steps.docgen.outputs.DOC_RESULTS }}' | while IFS='|' read -r MOD STATUS; do
          [ -z "$MOD" ] && continue
          echo "| ${MOD} | ${STATUS} |" >> "$REPORT_FILE"
        done

        cat >> "$REPORT_FILE" << FOOTEOF
        
        ---
        <sub>Generated by CI/CD Pipeline ‚Ä¢ $(date -u '+%Y-%m-%d %H:%M:%S UTC')</sub>
        FOOTEOF
    
    - name: Archive documentation
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: documentation
        path: docs/
        retention-days: 30
      continue-on-error: true
